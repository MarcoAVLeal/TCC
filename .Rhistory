geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+5,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv6,4))) +
axis.theme()
p6.cv
p6.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+0.15,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv6,4))) +
axis.theme()
p6.cv
library(rms)
### Kernel (Nadaraya-Watson) LOOCV
library(locfit)
tr= 1:nrow(df)
dftr= df[tr,]
number_of_bins = seq(2,50)
cv.errors = matrix( NA,nrow =  nrow(df), ncol = length(number_of_bins) )
for( i in number_of_bins){ # for each number of knots to test
for( j in tr ){ # for each fold
p              <-  seq(1,i-1,1)/i
knots          <-  quantile(dados$x  , p = p)
fit.spg1       <-  ols(as.formula(glue::glue("y ~ lsp(x, knots)")), data=df[tr!=j,])
spg1.pred    = predict( fit.spg1, newdata=data.frame(x = df$x[tr==j]) )
cv.errors[j,(i-1)] = mean( ( df$y[tr==j] - spg1.pred )^2,na.rm = TRUE ) }
}
cv.errors.mean = apply(cv.errors,2,mean,na.rm = TRUE)
cv.errors.stderr = apply(cv.errors,2,sd)/sqrt(nrow(dftr)-1)
min.cv.index = which.min( cv.errors.mean )-1
cv6 = cv.errors.mean[min.cv.index]
one_se_up_value = ( cv.errors.mean+cv.errors.stderr )[min.cv.index]
# Set up the x-y limits for plotting:
min_lim=min( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 0.9
max_lim=max( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 1.1
df <- data.frame(x = x, y = y)
df1 <- data.frame(x = number_of_bins, y = cv.errors.mean,EQM = cv.errors.mean)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p6.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+0.15,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv6,4))) +
axis.theme()
p6.cv
p6.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+5,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv6,4))) +
axis.theme()
p6.cv
p6.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+8,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv6,4))) +
axis.theme()
p6.cv
p6.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+8,y = max(cv.errors.mean)*0.8,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv6,4))) +
axis.theme()
p6.cv
library(rms)
### Kernel (Nadaraya-Watson) LOOCV
library(locfit)
tr= 1:nrow(df)
dftr= df[tr,]
number_of_bins = seq(2,50)
cv.errors = matrix( NA,nrow =  nrow(df), ncol = length(number_of_bins) )
for( i in number_of_bins){ # for each number of knots to test
for( j in tr ){ # for each fold
p              <-  seq(1,i-1,1)/i
knots          <-  quantile(dados$x  , p = p)
fit.spg3       <- lm(y ~ bs(x, knots = knots), data=df[tr!=j,] )
spg3.pred      = predict( fit.spg3, newdata=data.frame(x = df$x[tr==j]) )
cv.errors[j,(i-1)] = mean( ( df$y[tr==j] - spg3.pred )^2,na.rm = TRUE ) }
}
cv.errors.mean = apply(cv.errors,2,mean,na.rm = TRUE)
cv.errors.stderr = apply(cv.errors,2,sd)/sqrt(nrow(dftr)-1)
min.cv.index = which.min( cv.errors.mean )
cv7 = cv.errors.mean[min.cv.index]
one_se_up_value = ( cv.errors.mean+cv.errors.stderr )[min.cv.index]
# Set up the x-y limits for plotting:
min_lim=min( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 0.9
max_lim=max( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 1.1
df <- data.frame(x = x, y = y)
df1 <- data.frame(x = number_of_bins, y = cv.errors.mean,EQM = cv.errors.mean)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p7.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+5,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv7,4))) +
axis.theme()
p7.cv
p7.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+8,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index]-1,"\nEQM:",round(cv7,4))) +
axis.theme()
p7.cv
partial_plots <- cowplot::plot_grid(p1.cv,p2,p3,p4.cv,p5.cv,p6.cv,p7.cv,ncol=2,nrow = 4,labels=paste0(LETTERS[1:8],c("-Bin","-Média Móvel", "-Linha Móvel","-Loess","-Kernel","-Splines:Grau1","-Splines:Grau3")),vjust = -1,hjust = 0)
partial_plots <- cowplot::plot_grid(p1.cv,p1.cv,p1.cv,p4.cv,p5.cv,p6.cv,p7.cv,ncol=2,nrow = 4,labels=paste0(LETTERS[1:8],c("-Bin","-Média Móvel", "-Linha Móvel","-Loess","-Kernel","-Splines:Grau1","-Splines:Grau3")),vjust = -1,hjust = 0)
partial_plots
partial_plots <- cowplot::plot_grid(p1.cv,p1.cv,p1.cv,p4.cv,p5.cv,p6.cv,p7.cv,ncol=2,nrow = 4,labels=paste0(LETTERS[1:8],c("-Bin","-Média Móvel", "-Linha Móvel","-Loess","-Kernel","-Splines:Grau1","-Splines:Grau3")),vjust = -0.5,hjust = 0)
partial_plots
p1.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM")+
geom_vline(xintercept = min.cv.index,color ="red")+
annotate("text",x = min.cv.index+8,y = max(cv.errors.mean)*0.8,label=paste0("Largura:",min.cv.index,"\nEQM:",round(cv1,4))) +
axis.theme()
p1.cv
### Loess LOOCV
tr= 1:nrow(df)
dftr= df[tr,]
number_of_bins = seq(0.1,0.35,0.01)
cv.errors = matrix( NA,nrow =  nrow(df), ncol = length(number_of_bins) )
for( i in 1:length(number_of_bins)){ # for each number of knots to test
for( j in tr ){ # for each fold
fit.loess <- loess(y ~ x,degree=1, span = number_of_bins[i], data=df[tr!=j,])
loess.pred = predict( fit.loess, newdata=data.frame(x = df$x[tr==j]) )
cv.errors[j,i] = mean( ( df$y[tr==j] - loess.pred )^2,na.rm = TRUE ) }
}
cv.errors.mean = apply(cv.errors,2,mean,na.rm = TRUE)
cv.errors.stderr = apply(cv.errors,2,sd)/sqrt(nrow(dftr)-1)
min.cv.index = which.min( cv.errors.mean )
cv4 = cv.errors.mean[min.cv.index]
one_se_up_value = ( cv.errors.mean+cv.errors.stderr )[min.cv.index]
# Set up the x-y limits for plotting:
min_lim=min( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 0.9
max_lim=max( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 1.1
df <- data.frame(x = x, y = y)
df1 <- data.frame(x = number_of_bins, y = cv.errors.mean,EQM = cv.errors.mean)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+0.15,y = max(cv.errors.mean)*0.8,label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]+0.15,y = max(cv.errors.mean),label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.15,y = max(cv.errors.mean),label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean),label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean)*0.9,label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean),label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean)-0.15,label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean),label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean)*0.95,label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
p4.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean)*0.99,label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv4,4))) +
axis.theme()
p4.cv
### Kernel (Nadaraya-Watson) LOOCV
library(locfit)
tr= 1:nrow(df)
dftr= df[tr,]
number_of_bins = seq(0.1,0.35,0.01)
cv.errors = matrix( NA,nrow =  nrow(df), ncol = length(number_of_bins) )
for( i in 1:length(number_of_bins)){ # for each number of knots to test
for( j in tr ){ # for each fold
fit.kernel <- locfit(y ~ x,deg=1, alpha = number_of_bins[i],kern="gauss", data=df[tr!=j,])
kernel.pred = predict( fit.kernel, newdata=data.frame(x = df$x[tr==j]) )
cv.errors[j,i] = mean( ( df$y[tr==j] - kernel.pred )^2,na.rm = TRUE ) }
}
cv.errors.mean = apply(cv.errors,2,mean,na.rm = TRUE)
cv.errors.stderr = apply(cv.errors,2,sd)/sqrt(nrow(dftr)-1)
min.cv.index = which.min( cv.errors.mean )
cv5 = cv.errors.mean[min.cv.index]
one_se_up_value = ( cv.errors.mean+cv.errors.stderr )[min.cv.index]
# Set up the x-y limits for plotting:
min_lim=min( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 0.9
max_lim=max( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 1.1
df <- data.frame(x = x, y = y)
df1 <- data.frame(x = number_of_bins, y = cv.errors.mean,EQM = cv.errors.mean)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p5.cv <-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM") +
geom_vline(xintercept = number_of_bins[min.cv.index],color ="red")+
annotate("text",x = number_of_bins[min.cv.index]-0.05,y = max(cv.errors.mean)*.99,label=paste0("Span:",number_of_bins[min.cv.index],"\nEQM:",round(cv5,4))) +
axis.theme()
# bin  -  span = 11
fit1  <- glm(y ~ cut(x, par1), data=dados)
rm(list=ls())
source(file = "funcoes.R",encoding = "UTF-8")
library(tidyverse)
library(binsmooth)
library(knitr)
library(kableExtra)
library(additive.models)
library(rms)
library(locfit)
knitr::opts_chunk$set(echo = FALSE,warning= FALSE, message= FALSE,
out.width = "100%",fig.align = "center",size ="large",fig.height = 2.5)
# bin  -  span = 11
fit1  <- glm(y ~ cut(x, 11), data=dados)
# bin  -  span = 11
fit1  <- glm(y ~ cut(x, 11), data=df)
#library(tidyverse)
library(dslabs)
library(zoo)
library(igraph)
library(ggplot2)
library(dplyr)
library(tidyr)
library(wesanderson)
library(RColorBrewer)
###### DADOS  ########
set.seed(102585)
normal = rnorm(200)
x = seq(0, 50, length.out = 200)
y = 10 + (5*sin(pi*x/24)) + normal
dados = data.frame(x,y)
## plotando a curva real
true = 10 + (5*sin(pi*x/24))
df = cbind(dados$x, dados$y, true)
colnames(df) = c("x", "y","Curva real")
df = as_tibble(df) %>%
gather(key = "variable", value = "value", -x, -y )
library(FNN)
widths  <- c(5.1,15,30,45,60)
df      <- cbind(dados$x,dados$y)
for(k in widths){
#fit    <- knn.reg(train = dados$x, y = dados$y, k = k)
fit <- glm(y ~ cut(x, k), data=dados)
#fit    <- bin.smoother2(y = dados$y,k = k)$value
df     <- cbind(df,fit$fitted.values)
}
colnames(df) <- c("x","y",
paste0("A1\n", "L1:",widths[1]),
paste0("A2\n", "L2:",widths[2]),
paste0("A3\n", "L3:",widths[3]),
paste0("A4\n", "L4:",widths[4]),
paste0("A5\n", "L5:",widths[5]))
df           <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p1 <- plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y",line.s = 1,alpha.o = .95)
p1
library(smooth)
library(forecast)
widths    <- c(3,10,15,30,60)
df        <- cbind(dados$x,dados$y)
for(size in widths){
fit     <-  ma(x = dados$y,order = size)
#fit     <-  rollmean(x = dados$y,k = size,align = "center",na.pad = T)
df      <- cbind(df,fit)
}
colnames(df) <- c("x","y",paste0("A1\n", "L1:",widths[1]) ,
paste0("A2\n", "L2:",widths[2]),
paste0("A3\n", "L3:",widths[3]),
paste0("A4\n", "L4:",widths[4]),
paste0("A5\n", "L5:",widths[5]))
df <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p2 <- plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y",line.s = 1,alpha.o = .95)
library(smooth)
library(forecast)
widths    <- c(3,10,15,30,60)
df        <- cbind(dados$x,dados$y)
for(size in widths){
fit     <-  ma(x = dados$y,order = size)
#fit     <-  rollmean(x = dados$y,k = size,align = "center",na.pad = T)
df      <- cbind(df,fit)
}
colnames(df) <- c("x","y",paste0("A1\n", "L1:",widths[1]) ,
paste0("A2\n", "L2:",widths[2]),
paste0("A3\n", "L3:",widths[3]),
paste0("A4\n", "L4:",widths[4]),
paste0("A5\n", "L5:",widths[5]))
df <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p2 <- plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y",line.s = 1,alpha.o = .95)
library(igraph)
library(zoo)
widths    <- c(0.05,0.1,.15,0.25,.45)
df        <- cbind(dados$x,dados$y)
for(size in widths){
fit     <-  running.line(x = dados$x,y = dados$y,f = size)$fitted.values
df      <-  cbind(df,fit)
}
colnames(df) <- c("x","y",
paste0("A1\n", "L1:",widths[1]),
paste0("A2\n", "L2:",widths[2]),
paste0("A3\n", "L3:",widths[3]),
paste0("A4\n", "L4:",widths[4]),
paste0("A5\n", "L5:",widths[5]))
df <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p3 <-plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y")
spans = c(0.02,.10, 0.2,.3,.6)
df        <- cbind(dados$x,dados$y)
for(s in spans){
fit     <-  loess(y ~ x, degree=1, span = s, data=dados)$fitted
df      <-  cbind(df,fit)
}
colnames(df) <- c("x","y",
paste0("A1\n", "S1:",spans[1]),
paste0("A2\n", "S2:",spans[2]),
paste0("A3\n", "S3:",spans[3]),
paste0("A4\n", "S4:",spans[4]),
paste0("A5\n", "S5:",spans[5]))
df <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p4 <- plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y")
spans = c(2,6,20,40,60)
df        <- cbind(dados$x,dados$y)
for(s in spans){
fit     <-  ksmooth(x, y, kernel = "normal", bandwidth = s)$y
df      <-  cbind(df,fit)
}
colnames(df) <- c("x","y",
paste0("A1\n", "L1:",spans[1]),
paste0("A2\n", "L2:",spans[2]),
paste0("A3\n", "L3:",spans[3]),
paste0("A4\n", "L4:",spans[4]),
paste0("A5\n", "L5:",spans[5]))
df <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p5 <- plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y")
no <- function(x, no) ifelse(x < no, 0, x-no)  # funcao truncada, so pega os positivos
library(segmented)
#p_load(kirkegaard, rms)
library(rms)
library(pacman)
library(igraph)
library(zoo)
library(splines)
df        <- as.data.frame(cbind(dados$x,dados$y))
nos       = c(2,3,5,11,21)
colnames(df)<-c("x","y")
for(k in nos){
p         <-  seq(1,k-1,1)/k
knots     <-  quantile(df$x  , p = p)
fit       <-  ols(as.formula(glue::glue("y ~ lsp(x, knots)")), data = df)
df        <-  cbind(df,predict(fit))
}
colnames(df) <- c("x","y",
paste("A1\n", "Nós:",nos[1]-1),
paste("A2\n", "Nós:",nos[2]-1),
paste("A3\n", "Nós:",nos[3]-1),
paste("A4\n", "Nós:",nos[4]-1),
paste("A5\n", "Nós:",nos[5]-1)
)
df <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p6 <- plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y")
library(igraph)
library(zoo)
library(splines)
df        <- as.data.frame(cbind(dados$x,dados$y))
nos       = c(2,3,5,11,21)
for(k in nos){
p         <-  seq(1,k-1,1)/k
knots     <-  quantile(dados$x, p = p)
fit       <-  additive.spline.cubic(x = dados$x, y = dados$y, k = k,knots = knots)$fitted.values
df        <-  cbind(df,fit)
}
colnames(df) <- c("x","y",
paste("A1\n", "Nós:",nos[1]-1),
paste("A2\n", "Nós:",nos[2]-1),
paste("A3\n", "Nós:",nos[3]-1),
paste("A4\n", "Nós:",nos[4]-1),
paste("A5\n", "Nós:",nos[5]-1)
)
df <- as.tibble(df) %>%
gather(key = "variable", value = "value",-x,-y)
p7 <- plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y")
partial_plots <- cowplot::plot_grid(p1,p2,p3,p4,p5,p6,p7,ncol=2,nrow = 4,labels=paste0(LETTERS[1:8],c("-Bin","-Média Móvel", "-Linha Móvel","-Loess","-Kernel","-Splines:Grau1","-Splines:Grau3")),vjust = 1,hjust = 0)
partial_plots
# bin  -  span = 11
fit1  <- glm(y ~ cut(x, 11), data=dados)
# RM  -  span = 10
fit2 <- ma(x = dados$y,order = 10)
# RL  -  span = 0.1
fit3 <- with(dados, running.line(x = x, y = y, f = 0.1))
# loess -  span = 0.2
fit4 <- loess(y ~ x, degree=1, span = 0.2, data=dados)
# kernel - span = 6
fit5 <- it.kernel <- locfit(y ~ x,deg=1, alpha = 0.2,kern="gauss", data=dados)
k = 21
p         <-  seq(1,k-1,1)/k
knots     <-  quantile(dados$x  , p = p)
fit6       <-  ols(as.formula(glue::glue("y ~ lsp(x, knots)")), data = df)
# spline cubico
require(splines)
k = 21
p         <-  seq(1,k-1,1)/k
knots     <-  quantile(dados$x  , p = p)
fit7 <- lm(y ~ bs(x, knots = knots),data = dados )
spans = c(11,10,0.1, 0.2,6, 20,20)
df = cbind(x= dados$x, y = dados$y, Bin = fit1$value,RM = fit2,RL = fit3$fitted.values,Loess = fit4$fitted,Kernel = fit5$y,`Spline Grau 1`= predict(fit6),`Spline Cubico`= fit7$fitted)
df1 = df %>% as.data.frame
colnames(df) = c("x", "y",
paste0("A1\n", "Bin-", spans[1]),
paste0("A2\n", "RM-", spans[2]),
paste0("A3\n", "RL-", spans[3]),
paste0("A4\n", "Loess-", spans[4]),
paste0("A5\n", "Kernel-", spans[5]),
paste0("A6\n", "Spline Grau 1"),
paste0("A7\n", "Spline Grau 3"))
df = cbind(x= dados$x, y = dados$y, Bin = fit1$fitted.values,RM = fit2,RL = fit3$fitted.values,Loess = fit4$fitted,Kernel = fitted.values(fit5),`Spline Grau 1`= predict(fit6),`Spline Cubico`= fit7$fitted)
df1 = df %>% as.data.frame
colnames(df) = c("x", "y",
paste0("A1\n", "Bin-", spans[1]),
paste0("A2\n", "RM-", spans[2]),
paste0("A3\n", "RL-", spans[3]),
paste0("A4\n", "Loess-", spans[4]),
paste0("A5\n", "Kernel-", spans[5]),
paste0("A6\n", "Spline Grau 1"),
paste0("A7\n", "Spline Grau 3"))
df = as_tibble(df) %>%
gather(key = "variable", value = "value", -x, -y )
plot.mult.curves(df = dados,df_fit = df,title = NULL,labelx = "X",labely = "Y",line.s = 1,alpha.o = .85)
nas <- complete.cases(df1$RM)
library(Metrics)
df_metrics <- data.frame(Smoother = c("Bin","RM","RL", "Loess", "Kernel","Splines Grau 1","Splines Grau 3"),
EQM      =  c(rmse(actual = df1$y,df1$Bin),
rmse(actual = df1$y[nas],df1$RM[nas]),
rmse(actual = df1$y,df1$RL),
rmse(actual = df1$y,df1$Loess),
rmse(actual = df1$y,df1$Kernel),
rmse(actual = df1$y,df1$`Spline Grau 1`),
rmse(actual = df1$y,df1$`Spline Cubico`)))
kable_data(data = df_metrics,cap = "\\label{tab:tab_eqm_cenario1}Erro Quadrático Médio para os suavizadores Loess, Kernel e Spline Cúbico",foot = NULL)
