library(knitr)
library(kableExtra)
library(additive.models)
knitr::opts_chunk$set(echo = FALSE,warning= FALSE, message= FALSE,
out.width = "100%",fig.align = "center",size ="large",fig.height = 3)
library(additive.models)
library(caret)
n <- 1e3
set.seed(103159)
n           <- 50
x           <- seq(0,2,0.01)
norms       <- rnorm(length(x),0,0.25)
dens_gamma  <- dgamma(x = x,shape = 6,rate = 10)
y           <- dens_gamma + norms
dados       <- data.frame(x=x,y=y,variable = "Gamma(6,10)",value = dens_gamma)
df        <- cbind("X" = dados$x,"Y" = dados$y)
fit.loess              <-  lowess(x = dados$x,y = dados$y,f = 0.25)$y
fit.kssmooth           <-  ksmooth(x = dados$x,y = dados$y,kernel ="normal", bandwidth = 0.22)$y
k=3
p         <-  seq(1,k-1,1)/k
knots     <-  quantile(dados$x, p = p)
#fit.splinecubico       <-  lm(dados$y ~ ns(dados$x,knots = knots,df = 3) )$fitted.values
fit_splinecubico       <-  additive.spline.cubic(x = dados$x, y = dados$y, k = k,knots = c(0,0.5,0.75,1.25))$fitted.values[,1]
df1      <-  cbind( df,"Loess" = fit.loess,"Kernel" = fit.kssmooth,"Spline" = fit_splinecubico) %>% as.data.frame
# colnames(df1) <- c("x","y",
#                     paste("Ajuste1\nLowess\nSpan : 0.25 \n"),
#                     paste("Ajuste2\nKernel Smoother\nBandwidth : 0.22 \n"),
#                     paste("Ajuste3\nSplines de Regressão\nCubico\nNós : c(0.5,0.75,1.25)"))
#
# df1 <- as.tibble(df1) %>%
#   gather(key = "variable", value = "value",-x,-y)
#plot.mult.curves(df = df1,title = NULL)
library(Metrics)
df_metrics <- data.frame(Smoother = c("Loess","Kernel","Cubic Spline"),
EQM      =  c(rmse(actual = df1$Y,df1$Loess),rmse(actual = df1$Y,df1$Kernel),rmse(actual = df1$Y,df1$Spline)))
kable_data(data = df_metrics,cap = "Erro Quadrático Médio para os suavizadores Loess, Kernel e Spline Cúbico",foot = NULL)
locv1 <- function(x1, y1, nd, span, ntrial)
{
locvgcv <- function(sp, x1, y1)
{
nd <- length(x1)
assign("data1", data.frame(xx1 = x1, yy1 = y1))
fit.lo <- loess(yy1 ~ xx1, data = data1, span = sp, family = "gaussian", degree = 2, surface = "direct")
res <- residuals(fit.lo)
dhat2 <- function(x1, sp)
{
nd2 <- length(x1)
diag1 <- diag(nd2)
dhat <- rep(0, length = nd2)
for(jj in 1:nd2){
y2 <- diag1[, jj]
assign("data1", data.frame(xx1 = x1, yy1 = y2))
fit.lo <- loess(yy1 ~ xx1, data = data1, span = sp, family = "gaussian", degree = 2, surface = "direct")
ey <- fitted.values(fit.lo)
dhat[jj] <- ey[jj]
}
return(dhat)
}
dhat <- dhat2(x1, sp)
trhat <- sum(dhat)
sse <- sum(res^2)
cv <- sum((res/(1 - dhat))^2)/nd
gcv <- sse/(nd * (1 - (trhat/nd))^2)
return(gcv)
}
gcv <- sapply(as.list(span1), locvgcv, x1 = x1, y1 = y1)
#cvgcv <- unlist(cvgcv)
#cv <- cvgcv[attr(cvgcv, "names") == "cv"]
#gcv <- cvgcv[attr(cvgcv, "names") == "gcv"]
return(gcv)
}
nd <- length(df1$x)
xx <- x
yy <- y
ntrial <- 50
span1 <- seq(from = 0.1, by = 0.01, length = ntrial)
output.lo <- locv1(xx, yy, nd, span1, ntrial)
#cv <- output.lo
gcv <- output.lo
# plot(span1, gcv, type = "n", xlab = "span", ylab = "GCV")
# points(span1, gcv, pch = 3)
# lines(span1, gcv, lwd = 2)
eqm1 = gcv[which.min(gcv)]
gpcvmin <- seq(along = gcv)[gcv == min(gcv,na.rm = T)]
spangcv <- span1[gpcvmin]
gcvmin <- gcv[gpcvmin]
# points(spangcv, gcvmin, cex = 1, pch = 15)
df <- data.frame(x = span1, y = gcv)
df1      <-  cbind(df,EQM = gcv)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p1 <- ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Span",y = "EQM")+
geom_vline(xintercept = spangcv,color ="red")+
annotate("text",x = spangcv+0.025,y = max(df1$y),label=spangcv,) +
axis.theme()
library(np)
cv_bws_npreg <- function(x,y,bandwidths=(1:50)/50,
num.folds=10) {
require(np)
n <- length(x)
stopifnot(n> 1, length(y) == n)
stopifnot(length(bandwidths) > 1)
stopifnot(num.folds > 0, num.folds==trunc(num.folds))
fold_MSEs <- matrix(0,nrow=num.folds,
ncol=length(bandwidths))
colnames(fold_MSEs) = bandwidths
case.folds <- rep(1:num.folds,length.out=n)
case.folds <- sample(case.folds)
for (fold in 1:num.folds) {
train.rows = which(case.folds==fold)
x.train = x[train.rows]
y.train = y[train.rows]
x.test = x[-train.rows]
y.test = y[-train.rows]
for (bw in bandwidths) {
fit <- npreg(txdat=x.train,tydat=y.train,
exdat=x.test,eydat=y.test,bws=bw)
fold_MSEs[fold,paste(bw)] <- fit$MSE
}
}
CV_MSEs = colMeans(fold_MSEs)
best.bw = bandwidths[which.min(CV_MSEs)]
return(list(best.bw=best.bw,
CV_MSEs=CV_MSEs,
fold_MSEs=fold_MSEs))
}
fit.kernel <- cv_bws_npreg(x = x,y = y)
kbest <- fit.kernel$CV_MSEs %>% as.data.frame
bw <- rownames(kbest) %>% as.numeric
cverrors <- kbest[,1]
df <- data.frame(x = x, y = y)
df1 <- data.frame(x = bw, y = cverrors,EQM = cverrors)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p2 <- ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM")+
geom_vline(xintercept = fit.kernel$best.bw,color ="red")+
annotate("text",x = fit.kernel$best.bw+0.025,y = max(cverrors),label=fit.kernel$best.bw) +
axis.theme()
library(car)
fit.best.kernel <- ksmooth(x = x, y = y,kernel = "normal",bandwidth = fit.kernel$best.bw)
df1      <-  cbind( df,"Kernel" =fit.best.kernel$y ) %>% as.data.frame
colnames(df1) <- c("x","y",
paste0("Ajuste1\nKernel\nSpan :", fit.kernel$best.bw, "\n")
#paste("Ajuste2\nKernel Smoother\nBandwidth : 0.22 \n"),
#paste("Ajuste3\nSplines de Regressão\nCubico\nNós : c(0.5,0.75,1.25)")
)
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
#plot.mult.curves(df = df1,title = NULL)
library(splines)
library(ISLR)
attach(Wage)
set.seed(103159)
df <- data.frame(x = x,y = y)
tr= sample(1:nrow(df), nrow(df)/2)
te= (-tr)
dftr= df[tr,]
# Tuning parameter= the bins, suggest some possible values
number_of_bins = seq(1,20)
k = nrow(dftr)
folds = sample( x = 1:k, size = nrow(dftr), replace=FALSE )
cv.errors = matrix( NA, k, length(number_of_bins) )
for( i in 1:length(number_of_bins)){ # for each number of knots to test
for( j in 1:k ){ # for each fold
cubicfit = glm( y ~ bs( x, df=i), data=dftr[folds!=j,] )
cubicpred = predict( cubicfit, newdata=dftr[folds==j,] )
cv.errors[j,i] = mean( ( dftr[folds==j,]$y - cubicpred )^2 ) }
}
cv.errors.mean = apply(cv.errors,2,mean)
cv.errors.stderr = apply(cv.errors,2,sd)/sqrt(k)
min.cv.index = which.min( cv.errors.mean )
one_se_up_value = ( cv.errors.mean+cv.errors.stderr )[min.cv.index]
# Set up the x-y limits for plotting:
min_lim=min( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 0.9
max_lim=max( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 1.1
df <- data.frame(x = x, y = y)
df1 <- data.frame(x = number_of_bins, y = cv.errors.mean,EQM = cv.errors.mean)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p3<-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM")+
geom_vline(xintercept = min.cv.index,color ="red")+
annotate("text",x = min.cv.index+0.05,y = max(cv.errors.mean),label=min.cv.index) +
axis.theme()
# plot( number_of_bins, cv.errors.mean, ylim=c(min_lim,max_lim), pch=19, type='b', xlab='number of cut bins', ylab='CV estimate of the prediction error' )
# lines( number_of_bins, cv.errors.mean-cv.errors.stderr, lty='dashed' )
# lines( number_of_bins, cv.errors.mean+cv.errors.stderr, lty='dashed' )
# abline( h=one_se_up_value, col='red' )
library(car)
nob = min.cv.index
fit.best.spline = glm( y ~ bs( x, df=nob), data= df)
# dfte= df[te,]
# plot( dfte$x, dfte$y )
# aRng = range(dfte$x)
#
# Xage= seq( from=aRng[1], to=aRng[2], length.out=100 )
# Ywage= predict( fit, newdata=list( x=Xage ) )
# lines( Xage, Ywage, col='red', lw=4 )
df1      <-  cbind( df,"Spline Cúbico" = fit.best.spline$fitted.values) %>% as.data.frame
colnames(df1) <- c("x","y",
paste0("Ajuste1\nSpline Cúbico\nNós : ", min.cv.index, "\n")
#paste("Ajuste2\nKernel Smoother\nBandwidth : 0.22 \n"),
#paste("Ajuste3\nSplines de Regressão\nCubico\nNós : c(0.5,0.75,1.25)")
)
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
plot.mult.curves(df = df1,title = NULL)
partial_plots <- cowplot::plot_grid(p1,p2,p3,ncol=3,labels=LETTERS[1:3]);partial_plots
library(car)
# nob = min.cv.index
# fit.best.spline = glm( y ~ bs( x, df=nob), data= df)
# dfte= df[te,]
# plot( dfte$x, dfte$y )
# aRng = range(dfte$x)
#
# Xage= seq( from=aRng[1], to=aRng[2], length.out=100 )
# Ywage= predict( fit, newdata=list( x=Xage ) )
# lines( Xage, Ywage, col='red', lw=4 )
df1      <-  cbind( df,
"Loess" = fit.best.loess$fitted,
"Kernel Smoother" = fit.best.kernel$y,
"Spline Cúbico" = fit.best.spline$fitted.values) %>% as.data.frame
#library(tidyverse)
library(dslabs)
library(zoo)
library(igraph)
library(ggplot2)
library(dplyr)
library(tidyr)
library(wesanderson)
library(RColorBrewer)
############### PARA FAZER GRAFICOS ############
# textsize <- 10
# textsize2 <- 18
# mytheme <- theme(
#   axis.title = element_text(size = textsize),
#   axis.text = element_text(size = textsize),
#   legend.title = element_text(size = textsize),
#   legend.text = element_text(size = textsize))
#
# axis_theme <- theme_bw()  +
#   theme(
#     axis.text.x = element_text(angle = 0,face = "bold",size = textsize),
#     axis.text.y = element_text(angle = 0,face = "bold",size = textsize),
#     legend.background = element_rect(fill = "transparent", colour = NA,size = 2),
#     panel.background = element_rect(fill = "transparent", colour = NA),
#     plot.background = element_rect(fill = "white", colour = NA),
#     axis.title.x = element_text(colour = "black",size = textsize,face = "bold"),
#     axis.title.y = element_text(colour = "black",size = textsize,face = "bold"),
#     legend.title = element_text(colour = "black",size = 10),
#     pos_leg = "right",
#     legend.text = element_text(colour = "black",size = 8,face = "bold"),
#     panel.grid = element_line(linetype="dashed"),
#     panel.grid.major = element_line(colour = "gray"),
#     title =element_text(size=textsize, face='bold',hjust = 0.5),
#     plot.title = element_text(hjust = 0.5),
#     axis.title = element_text(color="#000000", face="bold", size=textsize,lineheight = 2))
# plot.mult.curves <- function(df,labelx="Eixo X",labely="Eixo Y",
#                              title = "Gráfico de Dispersão"
# ){
#
#   point.size  = 3
#   point.alpha = .2
#   point.color = "darkgrey"
#   line.size  = 0.8
#   line.alpha = 1
#   line.color = "red"
#   cores               <- c()
#   col.brew            <- brewer.pal(n = 9, name = "Set1")
#   colors              <- col.brew
#
#   #display.brewer.pal(, "Set1")
#   plot <- ggplot(data = df,aes(x=x,y=y))+
#     geom_point(alpha=point.alpha,size=point.size, col = point.color)+
#     labs(x = labelx,
#          y = labely,
#          color = "Legend")+
#     xlim(range(x)+c(-0,+0))+
#     ylim(range(y)+c(-0,+0))+
#     ggtitle(paste0(title))+
#     geom_line(aes(x=x,y = value,color=variable),size=line.size,alpha=line.alpha) +
#     scale_color_manual(values = colors)
#
#   plot
#
# }
#################################
###### DADOS  ########
set.seed(102585)
normal = rnorm(200)
x = seq(0, 50, length.out = 200)
y = 10 + (5*sin(pi*x/24)) + normal
dados = data.frame(x,y)
## plotando a curva real
true = 10 + (5*sin(pi*x/24))
df = cbind(dados$x, dados$y, true)
colnames(df) = c("x", "y","Curva real")
df = as_tibble(df) %>%
gather(key = "variable", value = "value", -x, -y )
plot.mult.curves(df,title = NULL)
# bin  -  span = 11
fit1 <- with(dados, ksmooth(x, y, kernel = "box", bandwidth = 11))
# loess -  span = 0.2
fit2 <- loess(y ~ x, degree=1, span = 0.2, data=dados)
# kernel - span = 6
fit3 <- with(dados, ksmooth(x, y, kernel = "normal", bandwidth = 6))
# spline cubico
require(splines)
fit4 <- lm(y ~ bs(x, knots = c(15,35)),data = dados )
spans = c(11, 0.2, 6)
df = cbind(dados$x, dados$y, fit1$y, fit2$fitted, fit3$y, fit4$fitted)
df1 = df
colnames(df) = c("x", "y",
paste("Ajuste1 - ", "Bin - tam = ", spans[1]),
paste("Ajuste2 - ", "Loess - Span = ", spans[2]),
paste("Ajuste3 - ", "Kernel - tam = ", spans[3]),
paste("Ajuste4 - ", "Spline cubico"))
df = as_tibble(df) %>%
gather(key = "variable", value = "value", -x, -y )
df1 = df %>% as.data.frame
# bin  -  span = 11
fit1 <- with(dados, ksmooth(x, y, kernel = "box", bandwidth = 11))
# loess -  span = 0.2
fit2 <- loess(y ~ x, degree=1, span = 0.2, data=dados)
# kernel - span = 6
fit3 <- with(dados, ksmooth(x, y, kernel = "normal", bandwidth = 6))
# spline cubico
require(splines)
fit4 <- lm(y ~ bs(x, knots = c(15,35)),data = dados )
spans = c(11, 0.2, 6)
df = cbind(dados$x, dados$y, fit1$y, fit2$fitted, fit3$y, fit4$fitted)
df1 = df %>% as.data.frame
colnames(df) = c("x", "y",
paste("Ajuste1 - ", "Bin - tam = ", spans[1]),
paste("Ajuste2 - ", "Loess - Span = ", spans[2]),
paste("Ajuste3 - ", "Kernel - tam = ", spans[3]),
paste("Ajuste4 - ", "Spline cubico"))
df = as_tibble(df) %>%
gather(key = "variable", value = "value", -x, -y )
# bin  -  span = 11
fit1 <- with(dados, ksmooth(x, y, kernel = "box", bandwidth = 11))
# loess -  span = 0.2
fit2 <- loess(y ~ x, degree=1, span = 0.2, data=dados)
# kernel - span = 6
fit3 <- with(dados, ksmooth(x, y, kernel = "normal", bandwidth = 6))
# spline cubico
require(splines)
fit4 <- lm(y ~ bs(x, knots = c(15,35)),data = dados )
spans = c(11, 0.2, 6)
df = cbind(x= dados$x, y = dados$y, Bin = fit1$y,Loess = fit2$fitted,Kernel = fit3$y,`Spline Cubico`= fit4$fitted)
df1 = df %>% as.data.frame
colnames(df) = c("x", "y",
paste("Ajuste1 - ", "Bin - tam = ", spans[1]),
paste("Ajuste2 - ", "Loess - Span = ", spans[2]),
paste("Ajuste3 - ", "Kernel - tam = ", spans[3]),
paste("Ajuste4 - ", "Spline cubico"))
df = as_tibble(df) %>%
gather(key = "variable", value = "value", -x, -y )
library(Metrics)
df_metrics <- data.frame(Smoother = c("Bin", "Loess","Kernel","Cubic Spline"),
EQM      =  c(rmse(actual = df1$y,df1$Bin),
rmse(actual = df1$y,df1$Loess),
rmse(actual = df1$y,df1$Kernel),
rmse(actual = df1$y,df1$`Spline Cubico`)))
kable_data(data = df_metrics,cap = "Erro Quadrático Médio para os suavizadores Loess, Kernel e Spline Cúbico",foot = NULL)
nd <- length(dados$x)
xx <- dados$x
yy <- dados$y
ntrial <- 50
span1 <- seq(from = 0.1, by = 0.01, length = ntrial)
output.lo <- locv1(xx, yy, nd, span1, ntrial)
#cv <- output.lo
gcv <- output.lo
# plot(span1, gcv, type = "n", xlab = "span", ylab = "GCV")
# points(span1, gcv, pch = 3)
# lines(span1, gcv, lwd = 2)
eqm1 = gcv[which.min(gcv)]
gpcvmin <- seq(along = gcv)[gcv == min(gcv,na.rm = T)]
spangcv <- span1[gpcvmin]
gcvmin <- gcv[gpcvmin]
# points(spangcv, gcvmin, cex = 1, pch = 15)
df <- data.frame(x = span1, y = gcv)
df1      <-  cbind(df,EQM = gcv)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p1 <- ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Span",y = "EQM")+
geom_vline(xintercept = spangcv,color ="red")+
annotate("text",x = spangcv+0.025,y = max(df1$y),label=spangcv,) +
axis.theme()
p1
fit.kernel <- cv_bws_npreg(x = dados$x,y = dados$y)
kbest <- fit.kernel$CV_MSEs %>% as.data.frame
bw <- rownames(kbest) %>% as.numeric
cverrors <- kbest[,1]
df <- data.frame(x = dados$x, y = dados$y)
df1 <- data.frame(x = bw, y = cverrors,EQM = cverrors)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p2 <- ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM")+
geom_vline(xintercept = fit.kernel$best.bw,color ="red")+
annotate("text",x = fit.kernel$best.bw+0.025,y = max(cverrors),label=fit.kernel$best.bw) +
axis.theme()
p2
library(splines)
library(ISLR)
attach(Wage)
set.seed(103159)
df <- data.frame(x = dados$x,y = dados$y)
tr= sample(1:nrow(df), nrow(df)/2)
te= (-tr)
dftr= df[tr,]
# Tuning parameter= the bins, suggest some possible values
number_of_bins = seq(1,20)
k = nrow(dftr)
folds = sample( x = 1:k, size = nrow(dftr), replace=FALSE )
cv.errors = matrix( NA, k, length(number_of_bins) )
for( i in 1:length(number_of_bins)){ # for each number of knots to test
for( j in 1:k ){ # for each fold
cubicfit = glm( y ~ bs( x, df=i), data=dftr[folds!=j,] )
cubicpred = predict( cubicfit, newdata=dftr[folds==j,] )
cv.errors[j,i] = mean( ( dftr[folds==j,]$y - cubicpred )^2 ) }
}
cv.errors.mean = apply(cv.errors,2,mean)
cv.errors.stderr = apply(cv.errors,2,sd)/sqrt(k)
min.cv.index = which.min( cv.errors.mean )
one_se_up_value = ( cv.errors.mean+cv.errors.stderr )[min.cv.index]
# Set up the x-y limits for plotting:
min_lim=min( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 0.9
max_lim=max( one_se_up_value, cv.errors.mean, cv.errors.mean-cv.errors.stderr, cv.errors.mean+cv.errors.stderr ) * 1.1
df <- data.frame(x = x, y = y)
df1 <- data.frame(x = number_of_bins, y = cv.errors.mean,EQM = cv.errors.mean)
colnames(df1) <- c("x","y",
paste("EQM"))
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
p3<-ggplot(df1,aes(x = x,y=y))+
geom_line()+
geom_point()+
labs(x = "Binwidth",y = "EQM")+
geom_vline(xintercept = min.cv.index,color ="red")+
annotate("text",x = min.cv.index+0.05,y = max(cv.errors.mean),label=min.cv.index) +
axis.theme()
# plot( number_of_bins, cv.errors.mean, ylim=c(min_lim,max_lim), pch=19, type='b', xlab='number of cut bins', ylab='CV estimate of the prediction error' )
# lines( number_of_bins, cv.errors.mean-cv.errors.stderr, lty='dashed' )
# lines( number_of_bins, cv.errors.mean+cv.errors.stderr, lty='dashed' )
# abline( h=one_se_up_value, col='red' )
p3
partial_plots <- cowplot::plot_grid(p1,p2,p3,ncol=3,labels=LETTERS[1:3]);partial_plots
library(car)
# nob = min.cv.index
# fit.best.spline = glm( y ~ bs( x, df=nob), data= df)
# dfte= df[te,]
# plot( dfte$x, dfte$y )
# aRng = range(dfte$x)
#
# Xage= seq( from=aRng[1], to=aRng[2], length.out=100 )
# Ywage= predict( fit, newdata=list( x=Xage ) )
# lines( Xage, Ywage, col='red', lw=4 )
df1      <-  cbind( df,
"Loess" = fit.best.loess$fitted,
"Kernel Smoother" = fit.best.kernel$y,
"Spline Cúbico" = fit.best.spline$fitted.values) %>% as.data.frame
library(car)
# nob = min.cv.index
# fit.best.spline = glm( y ~ bs( x, df=nob), data= df)
# dfte= df[te,]
# plot( dfte$x, dfte$y )
# aRng = range(dfte$x)
#
# Xage= seq( from=aRng[1], to=aRng[2], length.out=100 )
# Ywage= predict( fit, newdata=list( x=Xage ) )
# lines( Xage, Ywage, col='red', lw=4 )
nob = min.cv.index
fit.best.loess              <-  loess(data = df,formula =  y ~x,span = spangcv)
fit.best.kernel <- ksmooth(x = x, y = y,kernel = "normal",bandwidth = fit.kernel$best.bw)
fit.best.spline = glm( y ~ bs( x, df=nob), data= df)
df1      <-  cbind( df,
"Loess" = fit.best.loess$fitted,
"Kernel Smoother" = fit.best.kernel$y,
"Spline Cúbico" = fit.best.spline$fitted.values) %>% as.data.frame
colnames(df1) <- c("x","y",
paste0("Ajuste1\nLoess\nSpan : ", spangcv, "\n"),
paste("Ajuste2\nKernel Smoother\nBandwidth :", fit.kernel$best.bw, "\n"),
paste("Ajuste3\nSplines de Regressão\nCubico\nNós :", min.cv.index, "\n")
)
df1 <- as.tibble(df1) %>%
gather(key = "variable", value = "value",-x,-y)
plot.mult.curves(df = df1,title = NULL)
